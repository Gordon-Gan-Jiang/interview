[toc]

# 钉钉作业

## 开发的模块分别有：

### 传统作业：

老师布置作业、老师预览作业、学生做作业、老师预览作业、老师点评作业、班级作业报告、作业报告月报推送。

钉钉打卡任务：

布置周期打卡任务、学生完成打卡任务、打卡任务班级报告



## 结合业务，通过redis缓存和数据库减少对钉钉平台服务调用，达到销峰目的

原因： 在业务高峰期时，发现有些接口请求会触发系统的熔断策略（服务慢请求超过500个；出现大量的500类的请求，单实例超过40）。查看日志发现重要有两种原因

* 服务大量耗时在调用钉钉接口。
* 调用频繁被钉钉平台限流（针对于阿里云出口IP）

解决：

* 我们这边不会存储，用户的基本信息、用户关系信息、机构信息；结合业务，调用钉钉平台get请求服务加上缓存，为了保证数据的一致性，创建事件变更的数据库，钉钉教育平台会将用户的信息、用户关系、机构信息等变更事件信息，插入到对应的事件表中。 采用加了分布式锁的定时任务，每5秒加载一次，基于上一次查询的最大id，查询事件信息，解析事件，处理相应的缓存。

* 在高峰期将一些调用钉钉平台的get、put请求数据存于存储rides缓存中，这些请求不会影响产品的业务总流程，然后在半夜1点开始，分批的调用钉钉接口，将数据同步到钉钉，加了分布式锁。比如将习题信息同步给钉钉

## 根据业务场景拆分服务，减轻服务器压力，提高了系统性能；

 项目中音频打分接口是最高频的调用接口，并且音频打分接口会涉及到音频转码操作，非常耗CPU，将音频打分、服务商鉴权、控制服务商调用比例相关等相关业务抽离出来。并且音频打分接口的方式改为轮序调用，减少了大音频出现请求超时。



## 对亿量级表进行拆分，提高了数据库读写性能

历史数据迁移（双写一段时间，稳定后再切过去）：使用定时job将亿量级的表根据用户id取模运算分别存储到事先分配好的表中，用户id作为新创建好的表id。一共有30亿数据，分配了512张表，每张有500多万条数据。

原理：分片原理根据用户的id，算出表的下标，表的下标分别是从000到511。sql中表名为原名称+表下标的占位符；基于mybatis的动态sql原理，在运行时，将根据用户id取模算好的表下标替换sql中的表下标站位符。

1、继承DynamicContext类，根据参数将计算出表的下标，放入到DynamicContext的binds属性中（map）

2、实现SqlSource接口，调用getBoundSql方法获取BoundSql对象，将binds属性写入到boundSql属性中。



## 优化对用户音频的处理方式，提高了服务性能，并且为公司降低了基础设施成本

1、用户音频转码主要是为了支持前端音频播放控件的播放（不同的机型，会出现各种问题），将音频转码的操作后置，只有用户在点击播放时，才会触发音频的转码操作（wav转MP3）格式。

2、将半年前的用户音频进行删除处理，如果有半年前音频播放的请求，也就是oss桶不存在的音频播放请求，先根据钉钉平台产生的音频唯一标识下载音频，上传到oss桶中、音频转码等操作，最后将请求重定向。（直接播放，不需要前端拿到音频后再触发播放）。



# 内容管理平台

##   通过领域模型分析，调研老系统的习题和课件的特点，抽象出对应的业务对象，应用模板方法 定义一系列的业 务实现类，极具扩展性  

我们内容平台有各种类型的习题，每种类型的习题数据结构会存在着很大的差异。为了系统的扩展性，抽象出内容的模板配置，根据配置可以自定义习题的数据结构。



## 历史数据迁移

主要是将两个老系统中的表进行拆分合并操作，然后通过手动Job,将两个老系统的数据迁移过来。比如kelly和ellis老系统分别管理着书和课件。将这两个领域的对象抽象成新系统里面的应用，可以横向扩展。



## 分布式系统内容发布

内容平台的发布会做三件事情：

* 调用AI团队发布服务，不能立即给出发布成功的状态

* 将内容平台的数据，插入到内容消费的数据库里面
* 将教材到习题所有数据同步到排课系统

所以说整个过程耗时比较长，触发内容发布时，会将发布事件落入本地数据库中，返回前端发布事件唯一标识，前端轮询调用查看事件发布状态。整个过程中会异步将需要发布的内容数据封装成数据快照，上传至S3桶里，并将事件发布消息发送到RabbitMQ的消息队列中，然后内容消费服务订阅发布消息，触发AI团队发布服务，将AI团队发布事件落库，轮询查看AI团队发布事件状态，成功就处理第二步，将数据落入内容消费库中，然后将教材内容数据同步到排课系统。最后调用内容平台接口，返回事件发布状态



# 常规口语

### 通过 Spring Security 与 JWT 结合，提供一套多安全机制的体系

注入继承WebSecurityConfigurerAdapter(继承了WebSecurityConfigurerAdapter，WebSecurityConfigurerAdapter 初始化方法init(),会加载getHttp()，而getHttp（）会调用configure()方法。），重写了父类的configure方法（），添加各种认证过滤器，这些过滤器类实现了AbstractAuthenticationProcessingFilter。

* 核心组件
  1. SecurityContextHolder：提供对SecurityContext的访问
  2. SecurityContext,：持有Authentication对象和其他可能需要的信息
  3. AuthenticationManager 其中可以包含多个AuthenticationProvider
  4. ProviderManager对象为AuthenticationManager接口的实现类
  5. AuthenticationProvider 主要用来进行认证操作的类 调用其中的authenticate()方法去进行认证操作
  6. Authentication：Spring Security方式的认证主体
  7. GrantedAuthority：对认证主题的应用层面的授权，含当前用户的权限信息，通常使用角色表示
  8. UserDetails：构建Authentication对象必须的信息，可以自定义，可能需要访问DB得到

### 优化项目的资源上传方式

项目中在老师布置作业时候会上传大的视频，以及用户大的音频文件，会请求超时。将系统资源直接由后端上传改为，获取预签名让前端根据预签名上传，大的资源时，前端申请多个预签名，将资源切个成多个小文件，分开上传；最后由后端完成合并操作。



## JVM 调优

随着钉钉项目qps上来，通过阿里云的jvm监控看到，YGC非常的频繁，发现Eden区的总的容量时300M，两个servivor区各自100M，我先将堆内存从512M增大到1G；并且设置Eden区和两个servivor区的比例为8：1：1，减少更多的对象在Eden区。参数-XX:survivorRatio=8;

项目有一个版本上线了后，在高峰时刻，出现了频繁的FULLGC, cpu飙得很高，服务出现大量超时，我先获得内存溢出的dump文件，通过jstack分析发现，有一个同事，在利用阿里云OSS资源上传时，没有主动释放OSSClient对象。临时改为主动释放后，临时上线，后面单独定义一个bean。

设置生成-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=/path/to/heap/dump



## mysql 调优

在内容平台，多个用户在编辑同一块内容时，出现了死锁。数据库的隔离级别采用的是可重复读，程序中AB两个事务，sql加了共享锁, 先将符合条件的记录读取出来，这个时候都拥有了读锁，然后A事务去update时，需要获取B事务的读锁，而B事务去update时，也要获取A事务的读锁。

解决办法，使用排它锁，在sql上加上for update

将homework和homeworkresult表两个几千万条数据的表，用的是join连接查询，数据非常慢，后面分成代表查询。

